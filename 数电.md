## 进制转换  
### 十进制转二进制      
#### 1. 整数部分：用除 2 取余，逆序排列：    
example：    
25 ÷ 2 = 12 …… 1      
12 ÷ 2 = 6 …… 0      
6 ÷ 2 = 3 …… 0      
3 ÷ 2 = 1 …… 1      
1 ÷ 2 = 0 …… 1      
从下往上读余数：      
25₁₀ = 11001₂        
#### 2. 小数部分：用乘 2 取整，顺序排列：    
example：      
0.8125 × 2 = 1.625 → 取整 1，剩下 0.625      
0.625 × 2 = 1.25 → 取整 1，剩下 0.25    
0.25 × 2 = 0.5 → 取整 0，剩下 0.5      
0.5 × 2 = 1.0 → 取整 1，剩下 0.0（结束）      
从上往下读整数部分：      
0.8125₁₀ = 0.1101₂      
#### 3. 合并
###  二进制转十六进制
1. 整数部分从右到左 4 位一组，不足补 0：        
2. 小数部分从左到右 4 位一组，不足补 0：  
3. 合并    
example：  二进制：11001.1101    
0001 1001 → 对应 1(0001) 和 9(1001)
1101 → 对应 D(1101)
11001.1101 =19.D     

## 数字逻辑
取反时：取反符号下分开时，或变与，与变或（即加变乘，乘变加）。    
### 卡诺图      只允许2^n个格子
卡诺图具有**循环相邻性**：
左右边界相邻：最左列和最右列相邻    
上下边界相邻：最上行和最下行相邻        
四角相邻：四个角也相邻          
规则：圈尽可能多的1，将多个组合相加。    
列顺序是00→01→11→10（格雷码）        
## 组合逻辑    
优先级：非>与和与非>异或和同或>或和或非      
X⊕Y=X（取反）*Y+X*Y（取反)        
X⊙Y=X(取反)*Y(取反)+X*Y           
几路选择器就是剩下的那一个来决定输出的值是多少。    
详细的example见数电样卷。
<img width="747" height="1029" alt="image" src="https://github.com/user-attachments/assets/4af4b4a9-5f39-4ccc-a2d0-7c2846cc1b28" />      

**延迟计算**
<img width="1022" height="703" alt="image" src="https://github.com/user-attachments/assets/91bb7ede-0cca-4a90-aeec-0abd632cc4d1" />
## 时序逻辑
<img width="949" height="662" alt="image" src="https://github.com/user-attachments/assets/4ee99fed-d9f9-47f3-bf59-24b8e4b5e645" />      

## 加法减法原理

### 加法器

<img width="1106" height="525" alt="image" src="https://github.com/user-attachments/assets/4c0f8845-864a-4737-8143-ebc423534701" />

### 加减乘法运算      
**ZF**：result=0，ZF=1；          
**SF**：结果的最高位，SF=1，负；用于补码有符号判断              
**CF**：无符号溢出        
> 加法
>-> CF=carry out  
> 减法
>-> CF=1 --> carry out=0 --> 无符号A<B        

**OF**：带符号（补码）溢出    
OF=1 --> 同符号的加法得到的结果是不同的符号。    

判断大小       
有符号减法：OF=SF，大于      
无符号减法：CF=0，大于    


#### 乘法  
**原码的乘法**      
判断好符号位后直接乘      
符号位的异或判断0⊕1=1      
**补码的乘法**    
列式然后再通过查表进行操作最后得到乘积        
循环次数等于位数除以每一次循环移动的位数        

**溢出判断**
**无符号乘法**：如果把两个 n 位无符号数相乘并仅保留低 n 位，则发生溢出 ⇔ 完整乘积的高 n 位 ≠ 0。        
例子    
n=4，a=9 (1001₂)， b=3 (0011₂)。       
完整乘积 p = 27 (0001 1011₂)， high = 0001 ≠ 0 → 溢出（因为 27 ≥ 16）。        

**带符号乘法（补码）**：若用 n 位补码表示乘积（截低 n 位），     
高n位      
当 sign == 0（拟表示为正数）时，high == 0；      
当 sign == 1（拟表示为负数）时，high == (2^n - 1)（即全 1）。      
发生溢出 ⇔ 完整 2n 位乘积的高 n 位不是对低 n 位符号位（第 n−1 位）的符号扩展（即高 n 位既不是全 0 也不是全 1）           

## 指令系统
哪些寻址方式下的操作数在寄存器中？哪些寻址方式下的操作数在存储器中？        
寄存器直接寻址、的操作数在寄存器中。 （立即寻址的操作数在特殊寄存器IR中，可算可不算）      
寄存器间接、直接、间接、偏移（基址、变址、相对）这几种寻址方式的操作数都在存储器中。                 
转移跳转和调用指令的区别是什么？返回指令是否需要有地址码字段？        
转移（跳转）指令执行后，CPU将跳转到目标指令地址中执行，  无需返回。    

调用指令执行后，其返回地址（即调用指令的下条指令的地址）会保存到栈中或特定的寄存器中，            
然后再跳转到目标指令（被调用过程第一条指令）处执行，因此，被调用过程执行结束时会执行一条返回指令， 


返回指令将取出返回地址并置入PC，从而使CPU返回到调用指令处继续往后执行。            
如果返回地址存放在栈中或特定的寄存器中，则返回指令中可以不需要地址码；如果返回地址存放在某个通用寄存器中，          
则返回指令中需要给出通用寄存器编号（地址码）。        


核心步骤：CPU 从内存取指令 → 译码 → 取操作数 → 执行 → 存结果 → 更新PC（程序计数器）→ 循环        
CISC指令风格：变长操作码 / 变长指令字 / 指令多 / 寻址方式多 / 指令格式多           
RISC指令风格：指令少 / 寻址方式少 / 指令格式少 / 指令长度一致        
#### R型指令（例如：add, sub, and, or, slt等）    
格式：opcode+rd+rs1+rs2+funct      无立即数      
功能：R[rd] = R[rs1] op R[rs2]     
数据通路  ： 
- 从指令中提取rs1和rs2，从寄存器文件中读取两个操作数。    
- 将这两个操作数送入ALU。      
- ALU根据funct3和funct7（对于R型指令，ALU控制信号由funct3和funct7共同决定，例如add和sub通过funct7区分）执行相应操作。      
- ALU的结果在时钟周期结束时写回寄存器文件的rd端口。    
GPR：busA ← R[rs1], busB ← R[rs2]。        
ALUSrc = 0 -> ALU 输入 B = busB。 ALUOp 由 funct/ALUctrl 决定（如 ADD/SUB/AND 等）。        
ALU 计算 Result = busA op busB，输出暂存 ALUOut。        
RegWrite=1, MemtoReg=0, RegDst selects rd，busW ← ALUOut，把结果写回 R[rd]。            
PC ← PC + 4（或 PC+1），常在 IF 阶段更新（单周期或多周期均如此）。        

#### I型指令（算术逻辑运算，例如addi, andi, ori等）   
功能：R[rd] = R[rs1] op imm（立即数符号扩展后）   
数据通路：  
从指令中提取rs1，从寄存器文件中读取一个操作数。      
- 立即数扩展器将12位立即数符号扩展为32位。
- 并且经过多路选择器MUX    
- ALU的两个输入分别为寄存器读出的数据和扩展后的立即数。      
- ALU根据funct3执行相应操作（I型指令的funct7字段无效，因为I型指令的立即数只有12位，funct7部分被用于立即数编码）。      
- 结果写回寄存器文件的rd端口。
ID: A ← R[rs1]. ImmExt ← EXT(imm).      
EX: ALUSrc = 1 -> ALU B = ImmExt. ALUOp set to ADD/ORI/SLTI per opcode/funct3.      
ALU → ALUOut.      
WB: R[rd] ← ALUOut (RegWrite=1, MemtoReg=0).      
PC updates normal (PC+4) except for jalr where PC ← ALUOut possibly.
#### U型指令（例如lui, auipc）
功能：    
- lui: R[rd] = imm << 12（将20位立即数左移12位，低12位补0）      
- auipc: R[rd] = PC + (imm << 12)      
数据通路：
- 立即数扩展器将20位立即数（位于指令的31:12）左移12位（低12位补0）形成32位立即数。      
- 对于lui，这个立即数直接作为结果写回寄存器。      
- 对于auipc，需要将PC与该立即数相加，结果写回寄存器。
LUI: R[rd] ← imm << 12      
ID: ImmU ← IR.imm << 12      
WB: R[rd] ← ImmU (RegWrite=1, MemtoReg=0, ALU not used)      
AUIPC: R[rd] ← PC + (imm << 12)      
EX: ALUOut ← PC + ImmU        
WB: R[rd] ← ALUOut.          
#### L型指令（Load指令，例如lw, lh, lb等）    
功能：R[rd] = M[R[rs1] + imm]（从内存中读取一个数据，地址为R[rs1]加上符号扩展的立即数）      
数据通路：      
- 从寄存器文件读取rs1的值。      
- 立即数扩展器将12位立即数符号扩展为32位。        
- ALU执行加法，计算内存地址：地址 = R[rs1] + imm。        
- 数据存储器（DM）根据该地址读取数据。        
- 读取的数据写回寄存器文件的rd端口。
ID: A ← R[rs1], ImmExt←EXT(imm).        
EX: ALU computes address ALUOut ← A + ImmExt (ALUSrc=1, ALUOp=ADD).        
MEM: MDR ← Mem[ ALUOut ] (MemRead=1).        
WB: R[rd] ← MDR (MemtoReg=1, RegWrite=1).
关键连接：DataMem 的 Adr 接 ALUOut；DataMem 的 DataOut 接 MDR；MDR 接 MemtoReg MUX；MemtoReg=1 选择 MDR 写回寄存器。    
#### S型指令（Store指令，例如sw, sh, sb等）
功能：M[R[rs1] + imm] = R[rs2]      
数据通路：    
- 从寄存器文件读取rs1和rs2的值。    
- 立即数扩展器将12位立即数（注意S型指令的立即数由两部分组成）符号扩展为32位。      
- ALU执行加法，计算内存地址：地址 = R[rs1] + imm。    
- 将寄存器rs2的值写入数据存储器的该地址。
ID: A ← R[rs1] (base), B ← R[rs2] (store value), ImmExt.      
EX: ALUOut ← A + ImmExt.        
MEM: Mem[ALUOut] ← B (MemWrite=1). 也可能先写入 MDR then memory.        
WB: no register write.
关键连接：DataMem's DataIn must come from B (busB) or MDR with appropriate byte-enable. Address from ALUOut.        
#### B型指令（条件分支指令，例如beq, bne, blt等）
功能：if (R[rs1] op R[rs2]) then PC = PC + imm，否则PC = PC+4        
数据通路：  
- 从寄存器文件读取rs1和rs2的值。          
- 立即数扩展器将13位立即数（B型立即数由两部分组成，实际是13位，因为最低位为0，所以是12位立即数左移1位？注意：在RISC-V中，B型立
  即数是12位，但需要左移1位，所以是13位符号扩展，然后左移1位？实际上，B型立即数在指令中编码为12位，但形成32位立即数时
  需要将最低位置0，所以相当于13位立即数（符号扩展后）左移1位。但在单周期数据通路中，我们通常先扩展然后左移1位（或者直
  接扩展为32位，然后左移1位，但注意左移1位相当于乘以2）。          
- 同时，我们需要计算两个地址：PC+4 和 PC+imm（imm左移1位后符号扩展为32位，然后与PC相加）。      
- ALU对两个寄存器值进行比较（通过减法等，根据funct3决定比较类型），产生比较结果（如Zero标志，或者有符号比较结果等）。      
- 根据比较结果，通过一个多路选择器选择下一个PC的值：要么是PC+4，要么是PC+imm。      
ID: A ← R[rs1]; B ← R[rs2]; ImmExt.        
EX: ALU computes A - B (ALUOp=SUB) to generate Zero flag OR comparator 
unit checks equality; branch target ALUOut ← PC + ImmExt (or dedicated adder does PC+imm).    
If Zero && Branch → PC ← ALUOut (PCWrite with PCSrc select branch target). Else PC remains PC+4.    
Two typical implementations:          
Single ALU: Do A-B and branch target compute PC+Imm via same ALU in separate cycle or adder.      
Dedicated adder: dedicated PC + Imm adder produces branch target in same cycle; ALU just computes comparator.        
#### J型指令（无条件跳转，例如jal）
功能：R[rd] = PC+4; PC = PC + imm（imm是20位立即数，左移1位后符号扩展）    
数据通路：      
- 立即数扩展器将20位立即数（J型立即数编码类似B型，但更长）左移1位（因为跳转目标地址是2字节对齐的）
- 并符号扩展为32位，然后与PC相加得到跳转目标地址。      
- 同时，计算PC+4（下一条指令地址）。            
- 将PC+4写入寄存器文件的rd端口（作为返回地址）。        
- 将跳转目标地址写入PC。      
ID: compute ImmExt (target offset)      
EX: compute target = PC + ImmExt (ALU)      
WB: R[rd] ← PC + 4 (if link register required) (RegWrite=1, MemtoReg selects PC+4)      
PC update: PC ← target (PCWrite=1, PCSrc selects ALUOut)      
Note: The write-back of PC+4 must happen (store return address), so MemtoReg mux must be able to select PC+4.


























 
